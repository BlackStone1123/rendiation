use crate::*;

/// Generates vertex buffer from the source vertex buffer and remap table generated by
/// [generate_vertex_remap].
///
/// # Arguments
///
/// * `destination`: must contain enough space for the resulting vertex buffer
///   (`unique_vertex_count` elements, returned by [generate_vertex_remap])
/// * `vertices`: should have the initial vertex count and not the value returned by
///   [generate_vertex_remap]
pub fn remap_vertex_buffer<Vertex>(destination: &mut [Vertex], vertices: &[Vertex], remap: &[u32])
where
  Vertex: Copy,
{
  remap
    .iter()
    .filter(|dst| **dst != INVALID_INDEX)
    .enumerate()
    .for_each(|(src, dst)| destination[*dst as usize] = vertices[src]);
}

/// Generate index buffer from the source index buffer and remap table generated by meshopt_generateVertexRemap
///
/// destination must contain enough space for the resulting index buffer (index_count elements)
///  indices can be None if the input is unindexed
pub fn remap_index_buffer(
  destination: &mut [u32],
  indices: Option<&[u32]>,
  index_count: usize,
  remap: &[u32],
) {
  assert!(index_count % 3 == 0);

  for i in 0..index_count {
    let index = if let Some(indices) = indices {
      indices[i] as usize
    } else {
      i
    };
    assert!(remap[index] != INVALID_INDEX);
    destination[i] = remap[index];
  }
}

/// Generates a vertex remap table from the vertex buffer and an optional index buffer and returns
/// number of unique vertices.
///
/// As a result, all vertices that are binary equivalent map to the same (new) location, with no
/// gaps in the resulting sequence. Resulting remap table maps old vertices to new vertices and can
/// be used in [remap_vertex_buffer]/[remap_index_buffer].
///
/// Note that binary equivalence considers all `Stream::subset` bytes, including padding which
/// should be zero-initialized.
///
/// # Arguments
///
/// * `destination`: must contain enough space for the resulting remap table (`vertex_count`
///   elements defined by `vertices`)
/// * `indices`: can be `None` if the input is unindexed
pub fn generate_vertex_remap<Vertex: Eq + std::hash::Hash>(
  destination: &mut [u32],
  indices: Option<&[u32]>,
  vertices: &[Vertex],
) -> usize {
  generate_vertex_remap_inner(destination, indices, vertices.len(), |index| {
    vertices.get(index)
  })
}

fn generate_vertex_remap_inner<Vertex, Lookup>(
  destination: &mut [u32],
  indices: Option<&[u32]>,
  vertex_count: usize,
  lookup: Lookup,
) -> usize
where
  Lookup: Fn(usize) -> Vertex,
  Vertex: Eq + std::hash::Hash,
{
  let index_count = match indices {
    Some(buffer) => buffer.len(),
    None => vertex_count,
  };
  assert_eq!(index_count % 3, 0);

  destination.fill(INVALID_INDEX);

  let mut table = HashMap::with_capacity_and_hasher(vertex_count, BuildVertexHasher::default());

  let mut next_vertex = 0;

  for i in 0..index_count {
    let index = match indices {
      Some(buffer) => buffer[i] as usize,
      None => i,
    };
    assert!(index < vertex_count);

    if destination[index] == INVALID_INDEX {
      match table.entry(lookup(index)) {
        Entry::Occupied(entry) => {
          let value = *entry.get();
          assert!(destination[value] != INVALID_INDEX);
          destination[index] = destination[value];
        }
        Entry::Vacant(entry) => {
          entry.insert(index);
          destination[index] = next_vertex as u32;
          next_vertex += 1;
        }
      }
    }
  }

  assert!(next_vertex <= vertex_count);

  next_vertex
}

pub struct PositionalRemapping {
  pub remap: Vec<u32>,
  pub wedge: VertexWedgeLoops,
}

/// for each vertex, which other vertex is the next wedge that also maps to the
/// same vertex? entries in table form a (cyclic) wedge loop per vertex; for manifold vertices,
/// wedge[i] == remap[i] == i
pub struct VertexWedgeLoops {
  wedge: Vec<u32>,
}

impl VertexWedgeLoops {
  pub fn vertex_is_on_seam(&self, vertex_id: usize) -> bool {
    self.wedge[vertex_id] != vertex_id as u32
  }
  /// the simple seam is that only two vertex with same position form this seam
  /// if it's simple seam, return the pair vertex id, if not, return None
  pub fn vertex_is_on_simple_seam(&self, vertex_id: usize) -> Option<usize> {
    let next = self.wedge[vertex_id] as usize;
    let back = self.wedge[next] as usize;
    (back == vertex_id).then_some(next)
  }
  pub fn next_same_position_vertex(&self, vertex_id: usize) -> u32 {
    self.wedge[vertex_id]
  }
}

pub fn build_position_remap<Vertex>(vertices: &[Vertex]) -> PositionalRemapping
where
  Vertex: Positioned<Position = Vec3<f32>>,
{
  let mut wedge: Vec<_> = (0..vertices.len() as u32).collect();

  // for example we have (position, other attribute)
  // [(a, x), (a, x), (b, x), (c, x), (c, x), (d, x), (c, x)]
  // we have remap:
  // [0, 0, 2, 3, 3, 5, 3]
  // we have wedge:
  // [1, 0, 2, 6, 3, 5, 4]
  // in wedge table we can see the loop around vertex c: 3 -> 6 -> 4 -> 3
  // the "loop" is just a loop link list to visit all vertex that share one same position, do not
  // have the geometric meaning.

  let mut table = HashMap::with_capacity_and_hasher(vertices.len(), BuildPositionHasher::default());

  // build forward remap: for each vertex, which other (canonical) vertex does it map to?
  // we use position equivalence for this, and remap vertices to other existing vertices
  let remap: Vec<_> = vertices
    .iter()
    .enumerate()
    .map(
      |(i, vertex)| match table.entry(VertexPosition(vertex.position().into())) {
        Entry::Occupied(entry) => {
          let ri = *entry.get();

          let r = ri as usize;
          if r != i {
            wedge[i] = wedge[r];
            wedge[r] = i as u32;
          }

          ri
        }
        Entry::Vacant(entry) => {
          entry.insert(i as u32);
          i as u32
        }
      },
    )
    .collect();

  let wedge = VertexWedgeLoops { wedge };
  PositionalRemapping { remap, wedge }
}
