use crate::*;

/// this trait is to abstract the interface of different shader ptr types, for example
/// StorageNode, UniformNode, or **user defined ptr-like object**
///
/// the implementation should be able to implement Clone because every shader node can be cloned
/// so any shader runtime-like object should be clonable as well.
///
/// as this trait is untyped, the method may not valid to implement for some type, for example
/// it's impossible to array index to a none-array object. when this case happens, the method could
/// do anything in silence because validation error will eventually raised in later process.
///
/// todo, separate store ability
pub trait AbstractShaderPtr: Clone {
  fn field_index(&self, field_index: usize) -> Self;
  fn field_array_index(&self, index: Node<u32>) -> Self;
  fn array_length(&self) -> Node<u32>;
  fn load(&self) -> ShaderNodeRawHandle;
  fn store(&self, value: ShaderNodeRawHandle);
}

impl AbstractShaderPtr for ShaderNodeRawHandle {
  fn field_index(&self, field_index: usize) -> Self {
    ShaderNodeExpr::IndexStatic {
      field_index,
      target: *self,
    }
    .insert_api::<AnyType>()
    .handle()
  }

  fn field_array_index(&self, index: Node<u32>) -> Self {
    OperatorNode::Index {
      array: *self,
      entry: index.handle(),
    }
    .insert_api::<AnyType>()
    .handle()
  }

  fn array_length(&self) -> Node<u32> {
    make_builtin_call(ShaderBuiltInFunction::ArrayLength, [*self])
  }

  fn load(&self) -> ShaderNodeRawHandle {
    call_shader_api(|g| g.load(*self))
  }

  fn store(&self, value: ShaderNodeRawHandle) {
    call_shader_api(|g| g.store(*self, value))
  }
}

/// this trait is to mapping the `T` to it's typed shader access object. the access object
/// has type api to constraint valid access.
pub trait ShaderNodeAbstractAccessSource<Ptr: AbstractShaderPtr> {
  type Access;
  fn create_accessor_from_raw_ptr(ptr: Ptr) -> Self::Access;
}
pub type ShaderAccessorOf<T, Ptr> = <T as ShaderNodeAbstractAccessSource<Ptr>>::Access;

impl<T, Ptr: AbstractShaderPtr> ShaderNodeAbstractAccessSource<Ptr> for [T] {
  type Access = PointerArrayAccess<T, Ptr>;
  fn create_accessor_from_raw_ptr(ptr: Ptr) -> Self::Access {
    PointerArrayAccess {
      phantom: PhantomData,
      access: ptr,
    }
  }
}

pub struct PointerArrayAccess<T, Ptr: AbstractShaderPtr> {
  phantom: PhantomData<T>,
  access: Ptr,
}

impl<T: ShaderNodeAbstractAccessSource<Ptr>, Ptr: AbstractShaderPtr> PointerArrayAccess<T, Ptr> {
  pub fn index(&self, index: Node<u32>) -> T::Access {
    let item = self.access.field_array_index(index);
    T::create_accessor_from_raw_ptr(item)
  }
}

pub struct DirectLoadStorePrimitive<T, Ptr>(PhantomData<T>, Ptr);

impl<T, Ptr: AbstractShaderPtr> DirectLoadStorePrimitive<T, Ptr> {
  pub fn load(&self) -> Node<T> {
    unsafe { self.1.load().into_node() }
  }
  pub fn store(&self, value: Node<T>) {
    self.1.store(value.handle());
  }
}

macro_rules! impl_primitive_with_vec_mat_direct {
  ($ty: ty) => {
    impl_primitive_direct!($ty);
    impl_primitive_direct!(Vec2<$ty>);
    impl_primitive_direct!(Vec3<$ty>);
    impl_primitive_direct!(Vec4<$ty>);
    impl_primitive_direct!(Mat2<$ty>);
    impl_primitive_direct!(Mat3<$ty>);
    impl_primitive_direct!(Mat4<$ty>);
  };
}

macro_rules! impl_primitive_direct {
  ($ty: ty) => {
    impl<Ptr: AbstractShaderPtr> ShaderNodeAbstractAccessSource<Ptr> for $ty {
      type Access = DirectLoadStorePrimitive<$ty, Ptr>;
      fn create_accessor_from_raw_ptr(ptr: Ptr) -> Self::Access {
        DirectLoadStorePrimitive(PhantomData, ptr)
      }
    }
  };
}

impl_primitive_with_vec_mat_direct!(bool);
impl_primitive_with_vec_mat_direct!(i32);
impl_primitive_with_vec_mat_direct!(u32);
impl_primitive_with_vec_mat_direct!(f32);

///////// the macro expansion result demo:

pub struct MyStruct {
  pub a: f32,
  pub b: u32,
}

/// auto generated by macro
pub struct MyStructShaderInstance {
  pub a: Node<f32>,
  pub b: Node<f32>,
}

/// auto generated by macro
pub struct MyStructShaderPtrInstance<Ptr>(Ptr);

/// auto generated by macro
impl<Ptr: AbstractShaderPtr> MyStructShaderPtrInstance<Ptr> {
  pub fn load(&self) -> Node<MyStruct> {
    unsafe { self.0.load().into_node() }
  }
  pub fn store(&self, value: Node<MyStruct>) {
    self.0.store(value.handle());
  }

  pub fn a(&self) -> ShaderAccessorOf<f32, Ptr> {
    let v = self.0.field_index(0);
    f32::create_accessor_from_raw_ptr(v)
  }
  pub fn b(&self) -> ShaderAccessorOf<u32, Ptr> {
    let v = self.0.field_index(1);
    u32::create_accessor_from_raw_ptr(v)
  }
}
